import { useState, useEffect, useCallback, createContext, useContext } from 'react';
import { initializeApp } from 'firebase/app';
import { getAuth, signInWithCustomToken, onAuthStateChanged, signInAnonymously } from 'firebase/auth';
import { getFirestore, collection, onSnapshot, doc, getDocs, setDoc, addDoc, updateDoc, deleteDoc, writeBatch } from 'firebase/firestore';

// --- Firebase Configuration and Initialization ---
// The following global variables are provided by the Canvas environment.
// DO NOT MODIFY THESE.
const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';

// Context to provide Firebase instances and user ID throughout the app
const FirebaseContext = createContext(null);

const FirebaseProvider = ({ children }) => {
    const [db, setDb] = useState(null);
    const [auth, setAuth] = useState(null);
    const [userId, setUserId] = useState(null);
    const [isAuthReady, setIsAuthReady] = useState(false);

    useEffect(() => {
        const initFirebase = async () => {
            try {
                const app = initializeApp(firebaseConfig);
                const firestore = getFirestore(app);
                const authentication = getAuth(app);
                
                setDb(firestore);
                setAuth(authentication);

                if (initialAuthToken) {
                    await signInWithCustomToken(authentication, initialAuthToken);
                } else {
                    await signInAnonymously(authentication);
                }

                onAuthStateChanged(authentication, (user) => {
                    if (user) {
                        setUserId(user.uid);
                    } else {
                        // User ID is now only needed for authentication checks, not for the data path
                        setUserId('anonymous');
                    }
                    setIsAuthReady(true);
                });

            } catch (error) {
                console.error("Error initializing Firebase:", error);
            }
        };

        if (Object.keys(firebaseConfig).length > 0) {
            initFirebase();
        } else {
            console.error("Firebase config is missing.");
        }
    }, []);

    return (
        <FirebaseContext.Provider value={{ db, auth, userId, isAuthReady }}>
            {children}
        </FirebaseContext.Provider>
    );
};

// Custom hook to use the Firebase context
const useFirebase = () => {
    const context = useContext(FirebaseContext);
    if (!context) {
        throw new Error('useFirebase must be used within a FirebaseProvider');
    }
    return context;
};

// --- Reusable Modal Component ---
const Modal = ({ show, onClose, title, children, bgColor = 'bg-gray-800' }) => {
    if (!show) return null;

    return (
        <div className="fixed inset-0 z-50 flex items-center justify-center p-4 bg-black bg-opacity-50 overflow-y-auto">
            <div className={`${bgColor} rounded-lg shadow-xl w-full max-w-lg p-6 relative`}>
                <h2 className="text-2xl font-bold text-cyan-300 mb-4">{title}</h2>
                <button onClick={onClose} className="absolute top-4 right-4 text-gray-400 hover:text-white text-2xl font-bold">&times;</button>
                {children}
            </div>
        </div>
    );
};

// --- Main Line Dance Management Component ---
const LineDanceManagement = () => {
    const { db, userId, isAuthReady } = useFirebase();
    const [lineDances, setLineDances] = useState([]);
    const [queue, setQueue] = useState([]);
    const [searchTerm, setSearchTerm] = useState('');
    const [editingDance, setEditingDance] = useState(null);
    const [isModalOpen, setIsModalOpen] = useState(false);
    const [confirmDelete, setConfirmDelete] = useState(null);
    const [importDataModalOpen, setImportDataModalOpen] = useState(false);
    const [isLoading, setIsLoading] = useState(true);
    const [importing, setImporting] = useState(false);
    const [importText, setImportText] = useState('');
    const [viewMode, setViewMode] = useState('table'); // 'table' or 'card'
    const [sortBy, setSortBy] = useState({ field: 'danceName', direction: 'asc' });
    const [showBeginnerFriendlyOnly, setShowBeginnerFriendlyOnly] = useState(false);
    const [selectedDances, setSelectedDances] = useState(new Set());
    const [confirmBulkDelete, setConfirmBulkDelete] = useState(null);
    const [bulkEditMode, setBulkEditMode] = useState(false);
    const [editedDances, setEditedDances] = useState({});

    // Define the shared public collection path for line dances
    const lineDancesCollectionPath = `artifacts/${appId}/public/data/line_dances`;

    // Fetch line dances from Firestore in real-time
    useEffect(() => {
        if (!db || !isAuthReady) return;

        // Use the public collection for all users
        const lineDancesCollection = collection(db, lineDancesCollectionPath);
        const unsubscribe = onSnapshot(lineDancesCollection, (snapshot) => {
            const dances = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            setLineDances(dances);
            setIsLoading(false);
        }, (error) => {
            console.error("Error fetching line dances:", error);
            setIsLoading(false);
        });

        // Also listen to the public queue to enable "Add Next/Last" buttons
        const queueCollection = collection(db, `artifacts/${appId}/public/data/queue`);
        const unsubscribeQueue = onSnapshot(queueCollection, (snapshot) => {
            const queueData = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            // Filter for upcoming songs and sort by order
            queueData.sort((a, b) => a.order - b.order);
            setQueue(queueData);
        }, (error) => {
            console.error("Error fetching queue:", error);
        });

        return () => {
            unsubscribe();
            unsubscribeQueue();
        };
    }, [db, isAuthReady, userId]);

    // Handle form submission for adding or editing a dance
    const handleSaveDance = async (e, danceData) => {
        e.preventDefault();
        if (!db || !danceData.danceName) return;

        try {
            if (editingDance) {
                // Update existing dance in the public collection
                await updateDoc(doc(db, lineDancesCollectionPath, editingDance.id), danceData);
            } else {
                // Add new dance to the public collection
                await addDoc(collection(db, lineDancesCollectionPath), danceData);
            }
            setIsModalOpen(false);
            setEditingDance(null);
        } catch (error) {
            console.error("Error saving dance:", error);
        }
    };
    
    // Save all bulk edits
    const handleSaveBulkEdits = async () => {
        if (!db || Object.keys(editedDances).length === 0) return;

        const batch = writeBatch(db);
        const collectionRef = collection(db, lineDancesCollectionPath);

        Object.keys(editedDances).forEach(id => {
            const danceRef = doc(collectionRef, id);
            batch.update(danceRef, editedDances[id]);
        });
        
        try {
            await batch.commit();
            setEditedDances({});
            setBulkEditMode(false);
        } catch (error) {
            console.error("Error saving bulk edits:", error);
        }
    };

    // Handle deletion of a single dance
    const handleDeleteDance = async (id) => {
        if (!db) return;
        try {
            await deleteDoc(doc(db, lineDancesCollectionPath, id));
            setConfirmDelete(null);
        } catch (error) {
            console.error("Error deleting dance:", error);
        }
    };
    
    // Handle bulk deletion
    const handleBulkDelete = async () => {
        if (!db || !confirmBulkDelete) return;

        const batch = writeBatch(db);
        const collectionRef = collection(db, lineDancesCollectionPath);
        
        if (confirmBulkDelete.type === 'selected') {
            selectedDances.forEach(id => {
                batch.delete(doc(collectionRef, id));
            });
        } else if (confirmBulkDelete.type === 'all') {
            const allDances = await getDocs(collectionRef);
            allDances.forEach(d => {
                batch.delete(d.ref);
            });
        }
        
        try {
            await batch.commit();
            setSelectedDances(new Set());
            setConfirmBulkDelete(null);
        } catch (error) {
            console.error("Error performing bulk delete:", error);
        }
    };

    // Handle bulk import from TSV data
    const handleBulkImport = async () => {
        if (!db || !importText) return;
        setImporting(true);

        const lines = importText.split('\n').filter(line => line.trim() !== '');
        if (lines.length <= 1) {
            setImporting(false);
            return;
        }

        const headers = lines[0].split('\t').map(h => h.trim());
        const dataRows = lines.slice(1);
        const batch = writeBatch(db);

        // Define a mapping from TSV headers to Firestore field names
        const headerMap = {
            'Dance': 'danceName',
            'Level': 'difficulty',
            'Song': 'songTitle',
            'URL': 'stepSheetLink',
        };

        const batchRef = collection(db, lineDancesCollectionPath);

        dataRows.forEach((row) => {
            const values = row.split('\t').map(v => v.trim());
            const newDance = { isBeginnerFriendly: false }; // Default to false

            // Iterate through headers to build the newDance object
            headers.forEach((header, i) => {
                const key = headerMap[header];
                if (key && values[i]) {
                    newDance[key] = values[i];
                }
            });

            // Re-parsing the song and artist from the 'Song' column
            if (newDance.songTitle) {
                // Use a regex to capture text inside quotes as songTitle and the rest as songArtist
                const match = newDance.songTitle.match(/^"(.*?)"\s*(.*)$/);
                if (match) {
                    newDance.songTitle = match[1].trim();
                    newDance.songArtist = match[2].trim();
                } else {
                    // Fallback for cases without quotes, assume whole string is songTitle
                    newDance.songArtist = '';
                }
            }
            
            // Create a new document in the batch if the dance has a name
            if (newDance.danceName) {
                const newDocRef = doc(batchRef);
                batch.set(newDocRef, newDance);
            }
        });

        try {
            await batch.commit();
            setImportText('');
            setImportDataModalOpen(false);
        } catch (error) {
            console.error("Error performing bulk import:", error);
        } finally {
            setImporting(false);
        }
    };
    
    // Toggle the "Beginner Friendly" status of a dance
    const handleToggleBeginnerFriendly = async (dance) => {
        if (!db) return;
        const danceRef = doc(db, lineDancesCollectionPath, dance.id);
        await updateDoc(danceRef, { isBeginnerFriendly: !dance.isBeginnerFriendly });
    };

    const handleBulkToggleBeginnerFriendly = (dance) => {
        setEditedDances(prev => ({
            ...prev,
            [dance.id]: {
                ...prev[dance.id],
                isBeginnerFriendly: !dance.isBeginnerFriendly
            }
        }));
    };

    // Add a dance to the queue
    const handleAddToQueue = async (dance, position) => {
        if (!db) return;
        const upcomingQueue = queue.filter(q => !q.played);
        const batch = writeBatch(db);

        const newItemData = {
            type: 'song',
            danceName: dance.danceName,
            songName: dance.songTitle,
            artist: dance.songArtist,
            stepSheetUrl: dance.stepSheetLink || '',
            isBeginnerFriendly: dance.isBeginnerFriendly || false,
            played: false,
            likes: [],
            dislikes: []
        };

        const queueCollectionRef = collection(db, `artifacts/${appId}/public/data/queue`);

        if (position === 'next') {
            newItemData.order = upcomingQueue.length > 0 ? upcomingQueue[0].order + 1 : 0;
            const docRef = doc(queueCollectionRef);
            batch.set(docRef, newItemData);
            
        } else { // 'last'
            newItemData.order = upcomingQueue.length;
            const docRef = doc(queueCollectionRef);
            batch.set(docRef, newItemData);
        }
        await batch.commit();
    };
    
    // Toggle checkbox for multi-select
    const handleSelectDance = (id) => {
        setSelectedDances(prev => {
            const newSelected = new Set(prev);
            if (newSelected.has(id)) {
                newSelected.delete(id);
            } else {
                newSelected.add(id);
            }
            return newSelected;
        });
    };
    
    // Select all dances
    const handleSelectAll = () => {
        if (selectedDances.size === displayedDances.length) {
            setSelectedDances(new Set());
        } else {
            const allIds = new Set(displayedDances.map(d => d.id));
            setSelectedDances(allIds);
        }
    };
    
    const handleBulkEditChange = (id, field, value) => {
        const dance = lineDances.find(d => d.id === id);
        if (dance[field] !== value) {
             setEditedDances(prev => ({
                ...prev,
                [id]: {
                    ...prev[id],
                    [field]: value
                }
            }));
        } else {
            // Remove from editedDances if reverted to original value
            setEditedDances(prev => {
                const newEdits = { ...prev };
                delete newEdits[id];
                return newEdits;
            });
        }
    };

    // Sort and filter dances
    const sortedAndFilteredDances = useCallback(() => {
        let dances = [...lineDances];

        // Filter based on search term
        if (searchTerm) {
            dances = dances.filter(dance => 
                dance.danceName.toLowerCase().includes(searchTerm.toLowerCase()) ||
                dance.songTitle?.toLowerCase().includes(searchTerm.toLowerCase()) ||
                dance.songArtist?.toLowerCase().includes(searchTerm.toLowerCase()) ||
                dance.difficulty?.toLowerCase().includes(searchTerm.toLowerCase())
            );
        }
        
        // Filter by beginner friendly status
        if (showBeginnerFriendlyOnly) {
            dances = dances.filter(dance => dance.isBeginnerFriendly);
        }

        // Sort based on selected field and direction
        dances.sort((a, b) => {
            const aValue = a[sortBy.field]?.toLowerCase() || '';
            const bValue = b[sortBy.field]?.toLowerCase() || '';
            
            if (aValue < bValue) return sortBy.direction === 'asc' ? -1 : 1;
            if (aValue > bValue) return sortBy.direction === 'asc' ? 1 : -1;
            return 0;
        });

        return dances;
    }, [lineDances, searchTerm, sortBy, showBeginnerFriendlyOnly]);
    
    const displayedDances = sortedAndFilteredDances();

    const handleSortChange = (e) => {
        const newField = e.target.value;
        setSortBy(prev => ({
            field: newField,
            direction: prev.field === newField ? (prev.direction === 'asc' ? 'desc' : 'asc') : 'asc'
        }));
    };
    
    // UI for adding/editing a dance
    const DanceForm = ({ danceToEdit }) => {
        const [danceData, setDanceData] = useState(danceToEdit || {
            danceName: '',
            songTitle: '',
            songArtist: '',
            stepSheetLink: '',
            difficulty: 'Beginner',
            isBeginnerFriendly: false,
        });

        const handleChange = (e) => {
            const { name, value, type, checked } = e.target;
            setDanceData(prev => ({ ...prev, [name]: type === 'checkbox' ? checked : value }));
        };

        const handleSubmit = (e) => handleSaveDance(e, danceData);

        return (
            <form onSubmit={handleSubmit} className="space-y-4">
                <div>
                    <label className="block text-sm font-medium text-cyan-300">Dance Name</label>
                    <input type="text" name="danceName" value={danceData.danceName} onChange={handleChange} required className="mt-1 block w-full rounded-md bg-gray-700 text-white border-gray-600 shadow-sm focus:border-cyan-400 focus:ring focus:ring-cyan-400 focus:ring-opacity-50" />
                </div>
                <div>
                    <label className="block text-sm font-medium text-cyan-300">Song Title</label>
                    <input type="text" name="songTitle" value={danceData.songTitle} onChange={handleChange} className="mt-1 block w-full rounded-md bg-gray-700 text-white border-gray-600 shadow-sm focus:border-cyan-400 focus:ring focus:ring-cyan-400 focus:ring-opacity-50" />
                </div>
                <div>
                    <label className="block text-sm font-medium text-cyan-300">Song Artist</label>
                    <input type="text" name="songArtist" value={danceData.songArtist} onChange={handleChange} className="mt-1 block w-full rounded-md bg-gray-700 text-white border-gray-600 shadow-sm focus:border-cyan-400 focus:ring focus:ring-cyan-400 focus:ring-opacity-50" />
                </div>
                <div>
                    <label className="block text-sm font-medium text-cyan-300">Step Sheet Link</label>
                    <input type="url" name="stepSheetLink" value={danceData.stepSheetLink} onChange={handleChange} className="mt-1 block w-full rounded-md bg-gray-700 text-white border-gray-600 shadow-sm focus:border-cyan-400 focus:ring focus:ring-cyan-400 focus:ring-opacity-50" />
                </div>
                <div>
                    <label className="block text-sm font-medium text-cyan-300">Difficulty</label>
                    <select name="difficulty" value={danceData.difficulty} onChange={handleChange} className="mt-1 block w-full rounded-md bg-gray-700 text-white border-gray-600 shadow-sm focus:border-cyan-400 focus:ring focus:ring-cyan-400 focus:ring-opacity-50">
                        <option value="Beginner">Beginner</option>
                        <option value="Improver">Improver</option>
                        <option value="Intermediate">Intermediate</option>
                        <option value="Advanced">Advanced</option>
                    </select>
                </div>
                <div className="flex items-center space-x-2">
                    <input type="checkbox" id="isBeginnerFriendly" name="isBeginnerFriendly" checked={danceData.isBeginnerFriendly} onChange={handleChange} className="form-checkbox text-blue-500 bg-gray-700 rounded-md focus:ring-cyan-400" />
                    <label htmlFor="isBeginnerFriendly" className="text-sm font-medium text-cyan-300">Beginner Friendly</label>
                </div>
                <div className="flex justify-end space-x-2">
                    <button type="button" onClick={() => { setIsModalOpen(false); setEditingDance(null); }} className="px-4 py-2 text-white bg-gray-600 rounded-lg hover:bg-gray-700">Cancel</button>
                    <button type="submit" className="px-4 py-2 text-gray-900 bg-cyan-500 rounded-lg hover:bg-cyan-600">Save</button>
                </div>
            </form>
        );
    };

    return (
        <div className="min-h-screen bg-gray-900 text-white p-4 sm:p-8">
            <style>{`
                .loader {
                    border: 4px solid #f3f3f3;
                    border-top: 4px solid #3498db;
                    border-radius: 50%;
                    width: 24px;
                    height: 24px;
                    animation: spin 1s linear infinite;
                }
                @keyframes spin {
                    0% { transform: rotate(0deg); }
                    100% { transform: rotate(360deg); }
                }
                .user-id-text {
                    word-break: break-all;
                }
                .neon-pink-bg {
                    background-color: #ff00ff;
                }
                .neon-glow {
                    box-shadow: 0 0 5px #ff00ff, 0 0 10px #ff00ff;
                }
            `}</style>
            
            {/* Confirmation Modal for single delete */}
            <Modal show={confirmDelete} onClose={() => setConfirmDelete(null)} title="Confirm Deletion">
                <p className="text-gray-300 mb-4">Are you sure you want to delete the dance "{confirmDelete?.danceName}"? This action cannot be undone.</p>
                <div className="flex justify-end space-x-2">
                    <button onClick={() => setConfirmDelete(null)} className="px-4 py-2 text-white bg-gray-600 rounded-lg hover:bg-gray-700">Cancel</button>
                    <button onClick={() => handleDeleteDance(confirmDelete.id)} className="px-4 py-2 text-white bg-red-600 rounded-lg hover:bg-red-700">Delete</button>
                </div>
            </Modal>
            
            {/* Confirmation Modal for bulk delete */}
            <Modal show={confirmBulkDelete} onClose={() => setConfirmBulkDelete(null)} title="Confirm Bulk Deletion">
                <p className="text-gray-300 mb-4">
                    {confirmBulkDelete?.type === 'selected' 
                        ? `Are you sure you want to delete ${selectedDances.size} selected dance(s)?`
                        : `Are you sure you want to delete ALL (${lineDances.length}) dances?`}
                     This action cannot be undone.
                </p>
                <div className="flex justify-end space-x-2">
                    <button onClick={() => setConfirmBulkDelete(null)} className="px-4 py-2 text-white bg-gray-600 rounded-lg hover:bg-gray-700">Cancel</button>
                    <button onClick={handleBulkDelete} className="px-4 py-2 text-white bg-red-600 rounded-lg hover:bg-red-700">Delete</button>
                </div>
            </Modal>

            {/* Add/Edit Modal */}
            <Modal show={isModalOpen} onClose={() => { setIsModalOpen(false); setEditingDance(null); }} title={editingDance ? "Edit Line Dance" : "Add New Line Dance"}>
                <DanceForm danceToEdit={editingDance} />
            </Modal>

            {/* Bulk Import Modal */}
            <Modal show={importDataModalOpen} onClose={() => setImportDataModalOpen(false)} title="Import Data from TSV">
                <p className="text-gray-300 mb-4">Paste your tab-separated data here. The first row should contain the headers: "Dance", "Level", "Song", "URL".</p>
                <textarea 
                    value={importText} 
                    onChange={(e) => setImportText(e.target.value)} 
                    placeholder="Dance&#9;Level&#9;Song&#9;URL" 
                    className="w-full h-48 p-2 rounded-md bg-gray-700 text-white border-gray-600 focus:outline-none focus:ring focus:ring-cyan-400 focus:ring-opacity-50"
                ></textarea>
                <div className="flex justify-end mt-4">
                    <button onClick={handleBulkImport} disabled={importing} className="px-4 py-2 text-gray-900 bg-cyan-500 rounded-lg hover:bg-cyan-600 disabled:opacity-50 flex items-center gap-2">
                        {importing && <div className="loader"></div>}
                        Import Data
                    </button>
                </div>
            </Modal>

            {/* Main UI */}
            <header className="mb-8">
                <h1 className="text-3xl font-bold text-cyan-400 mb-2">Line Dance Management</h1>
                <p className="text-gray-400">Manage your master list of line dances.</p>
                <div className="mt-2 text-sm text-gray-500 user-id-text">
                    Firestore User ID: {userId}
                </div>
            </header>

            <div className="flex flex-col sm:flex-row flex-wrap justify-between items-center mb-6 gap-2">
                <input 
                    type="text" 
                    placeholder="Search dances..." 
                    value={searchTerm} 
                    onChange={(e) => setSearchTerm(e.target.value)} 
                    className="w-full sm:w-1/3 p-3 rounded-md bg-gray-700 text-white border-gray-600 focus:outline-none focus:ring-2 focus:ring-cyan-400 order-1" 
                />
                <div className="flex items-center space-x-2 flex-wrap order-2">
                    <label htmlFor="sort-by" className="text-gray-400 text-sm">Sort by:</label>
                    <select id="sort-by" value={sortBy.field} onChange={handleSortChange} className="p-2 rounded-md bg-gray-700 text-white border-gray-600">
                        <option value="danceName">Dance Name</option>
                        <option value="songTitle">Song Title</option>
                        <option value="songArtist">Song Artist</option>
                        <option value="difficulty">Difficulty</option>
                    </select>
                    <button onClick={() => setSortBy(prev => ({ ...prev, direction: prev.direction === 'asc' ? 'desc' : 'asc' }))} className="p-2 text-white bg-gray-600 rounded-lg hover:bg-gray-700">
                        {sortBy.direction === 'asc' ? (
                            <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                <path fillRule="evenodd" d="M14.707 12.707a1 1 0 01-1.414 0L10 9.414l-3.293 3.293a1 1 0 01-1.414-1.414l4-4a1 1 0 011.414 0l4 4a1 1 0 010 1.414z" clipRule="evenodd" />
                            </svg>
                        ) : (
                            <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                <path fillRule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clipRule="evenodd" />
                            </svg>
                        )}
                    </button>
                    <button onClick={() => setShowBeginnerFriendlyOnly(prev => !prev)} 
                            className={`p-2 rounded-full transition-colors font-bold w-10 h-10 flex items-center justify-center 
                                ${showBeginnerFriendlyOnly ? 'neon-pink-bg text-white neon-glow' : 'bg-gray-700 text-gray-400 border-2 border-gray-600'}`}
                            title="Filter by Beginner Friendly">
                        B
                    </button>
                    <button onClick={() => setViewMode(viewMode === 'table' ? 'card' : 'table')} className="p-2 text-white bg-gray-600 rounded-lg hover:bg-gray-700">
                        {viewMode === 'table' ? (
                            <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                <path d="M10 3a1 1 0 00-1 1v2a1 1 0 002 0V4a1 1 0 00-1-1z" />
                                <path fillRule="evenodd" d="M4 3a1 1 0 00-1 1v12a1 1 0 001 1h12a1 1 0 001-1V4a1 1 0 00-1-1H4zm1 2h10v2H5V5zm0 4h10v2H5V9zm0 4h10v2H5v-2z" clipRule="evenodd" />
                            </svg>
                        ) : (
                            <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                <path d="M5 3a2 2 0 00-2 2v2a2 2 0 002 2h2a2 2 0 002-2V5a2 2 0 00-2-2H5zM5 11a2 2 0 00-2 2v2a2 2 0 002 2h2a2 2 0 002-2v-2a2 2 0 00-2-2H5zM13 3a2 2 0 00-2 2v2a2 2 0 002 2h2a2 2 0 002-2V5a2 2 0 00-2-2h-2zM13 11a2 2 0 00-2 2v2a2 2 0 002 2h2a2 2 0 002-2v-2a2 2 0 00-2-2h-2z" />
                            </svg>
                        )}
                    </button>
                    <button onClick={() => setImportDataModalOpen(true)} className="px-4 py-2 text-white bg-green-600 rounded-lg hover:bg-green-700">
                        Import TSV
                    </button>
                    <button onClick={() => setIsModalOpen(true)} className="px-4 py-2 text-white bg-blue-600 rounded-lg hover:bg-blue-700">
                        Add New Dance
                    </button>
                </div>
            </div>
            
            <div className="flex flex-col sm:flex-row space-y-2 sm:space-y-0 sm:space-x-2 mb-4">
                <button onClick={() => setBulkEditMode(prev => !prev)} className={`px-4 py-2 font-bold rounded-lg transition-colors ${bulkEditMode ? 'bg-cyan-500 text-gray-900 hover:bg-cyan-600' : 'bg-gray-600 text-white hover:bg-gray-700'}`}>
                    {bulkEditMode ? 'Exit Bulk Edit' : 'Toggle Bulk Edit Mode'}
                </button>
                {bulkEditMode && (
                    <>
                        <button onClick={handleSaveBulkEdits} disabled={Object.keys(editedDances).length === 0} className="px-4 py-2 text-white bg-green-600 rounded-lg hover:bg-green-700 disabled:opacity-50">
                            Save Changes ({Object.keys(editedDances).length})
                        </button>
                        <button onClick={() => setConfirmBulkDelete({ type: 'selected' })} disabled={selectedDances.size === 0} className="px-4 py-2 text-white bg-red-600 rounded-lg hover:bg-red-700 disabled:opacity-50">
                            Delete Selected ({selectedDances.size})
                        </button>
                        <button onClick={() => setConfirmBulkDelete({ type: 'all' })} className="px-4 py-2 text-white bg-red-800 rounded-lg hover:bg-red-900">
                            Delete All
                        </button>
                    </>
                )}
            </div>

            <div className="bg-gray-800 rounded-lg shadow overflow-hidden">
                {displayedDances.length === 0 ? (
                    <div className="p-6 text-center text-gray-500">
                        No line dances found. Add some or import from your TSV file!
                    </div>
                ) : (
                    viewMode === 'table' ? (
                        <div className="overflow-x-auto">
                            <table className="min-w-full divide-y divide-gray-700 table-fixed">
                                <thead className="bg-gray-700">
                                    <tr>
                                        {bulkEditMode && (
                                            <th scope="col" className="px-3 py-2 text-left text-xs font-medium text-gray-400 uppercase tracking-wider w-[5%]">
                                                <input type="checkbox" onChange={handleSelectAll} checked={selectedDances.size > 0 && selectedDances.size === displayedDances.length} className="form-checkbox text-blue-500 bg-gray-700 rounded-md focus:ring-cyan-400" />
                                            </th>
                                        )}
                                        <th scope="col" className={`px-3 py-2 text-left text-xs font-medium text-gray-400 uppercase tracking-wider ${bulkEditMode ? 'w-[20%]' : 'w-[25%]'}`}>Dance Name</th>
                                        <th scope="col" className={`px-3 py-2 text-left text-xs font-medium text-gray-400 uppercase tracking-wider ${bulkEditMode ? 'w-[20%]' : 'w-[25%]'}`}>Song Title</th>
                                        <th scope="col" className={`px-3 py-2 text-left text-xs font-medium text-gray-400 uppercase tracking-wider ${bulkEditMode ? 'w-[20%]' : 'w-[20%]'}`}>Song Artist</th>
                                        <th scope="col" className={`px-3 py-2 text-left text-xs font-medium text-gray-400 uppercase tracking-wider ${bulkEditMode ? 'w-[15%]' : 'w-[15%]'}`}>Difficulty</th>
                                        <th scope="col" className={`px-3 py-2 text-left text-xs font-medium text-gray-400 uppercase tracking-wider ${bulkEditMode ? 'w-[10%]' : 'w-[10%]'}`}>B. Friendly</th>
                                        <th scope="col" className="px-3 py-2 text-right text-xs font-medium text-gray-400 uppercase tracking-wider w-1/4">Actions</th>
                                    </tr>
                                </thead>
                                <tbody className="bg-gray-800 divide-y divide-gray-700">
                                    {displayedDances.map((dance) => (
                                        <tr key={dance.id} className={selectedDances.has(dance.id) ? 'bg-gray-700' : ''}>
                                            {bulkEditMode && (
                                                <td className="px-3 py-2 text-sm font-medium">
                                                    <input type="checkbox" checked={selectedDances.has(dance.id)} onChange={() => handleSelectDance(dance.id)} className="form-checkbox text-blue-500 bg-gray-700 rounded-md focus:ring-cyan-400" />
                                                </td>
                                            )}
                                            <td className="px-3 py-2 text-sm font-medium text-white break-words">
                                                {bulkEditMode ? (
                                                    <input type="text" value={editedDances[dance.id]?.danceName ?? dance.danceName} onChange={(e) => handleBulkEditChange(dance.id, 'danceName', e.target.value)} className="w-full bg-gray-600 border border-gray-500 rounded p-1" />
                                                ) : (
                                                    dance.danceName
                                                )}
                                            </td>
                                            <td className="px-3 py-2 text-sm text-gray-300 break-words">
                                                {bulkEditMode ? (
                                                    <input type="text" value={editedDances[dance.id]?.songTitle ?? dance.songTitle} onChange={(e) => handleBulkEditChange(dance.id, 'songTitle', e.target.value)} className="w-full bg-gray-600 border border-gray-500 rounded p-1" />
                                                ) : (
                                                    dance.songTitle
                                                )}
                                            </td>
                                            <td className="px-3 py-2 text-sm text-gray-300 break-words">
                                                {bulkEditMode ? (
                                                    <input type="text" value={editedDances[dance.id]?.songArtist ?? dance.songArtist} onChange={(e) => handleBulkEditChange(dance.id, 'songArtist', e.target.value)} className="w-full bg-gray-600 border border-gray-500 rounded p-1" />
                                                ) : (
                                                    dance.songArtist
                                                )}
                                            </td>
                                            <td className="px-3 py-2 text-sm text-gray-300 break-words">
                                                {bulkEditMode ? (
                                                    <select value={editedDances[dance.id]?.difficulty ?? dance.difficulty} onChange={(e) => handleBulkEditChange(dance.id, 'difficulty', e.target.value)} className="w-full bg-gray-600 border border-gray-500 rounded p-1">
                                                        <option value="Beginner">Beginner</option>
                                                        <option value="Improver">Improver</option>
                                                        <option value="Intermediate">Intermediate</option>
                                                        <option value="Advanced">Advanced</option>
                                                    </select>
                                                ) : (
                                                    dance.difficulty
                                                )}
                                            </td>
                                            <td className="px-3 py-2">
                                                {bulkEditMode ? (
                                                    <button onClick={() => handleBulkToggleBeginnerFriendly(dance)} className={`rounded-full w-8 h-8 flex items-center justify-center font-bold transition-colors ${editedDances[dance.id]?.isBeginnerFriendly ?? dance.isBeginnerFriendly ? 'neon-pink-bg text-white hover:bg-pink-600' : 'bg-gray-600 text-gray-400 hover:bg-gray-700'}`}>
                                                        B
                                                    </button>
                                                ) : (
                                                    <button onClick={() => handleToggleBeginnerFriendly(dance)} className={`rounded-full w-8 h-8 flex items-center justify-center font-bold transition-colors ${dance.isBeginnerFriendly ? 'bg-pink-500 text-white hover:bg-pink-600' : 'bg-gray-600 text-gray-400 hover:bg-gray-700'}`}>
                                                        B
                                                    </button>
                                                )}
                                            </td>
                                            <td className="px-3 py-2 text-right text-sm font-medium">
                                                <div className="flex justify-end space-x-1 items-center">
                                                    <button onClick={() => handleAddToQueue(dance, 'next')} className="bg-green-600 hover:bg-green-700 text-white text-xs font-bold py-1 px-2 rounded flex items-center gap-1">
                                                        <svg xmlns="http://www.w3.org/2000/svg" className="h-3 w-3" viewBox="0 0 20 20" fill="currentColor">
                                                            <path fillRule="evenodd" d="M10 5a1 1 0 011 1v3h3a1 1 0 110 2h-3v3a1 1 0 11-2 0v-3H6a1 1 0 110-2h3V6a1 1 0 011-1z" clipRule="evenodd" />
                                                        </svg>
                                                        Next
                                                    </button>
                                                    <button onClick={() => handleAddToQueue(dance, 'last')} className="bg-blue-600 hover:bg-blue-700 text-white text-xs font-bold py-1 px-2 rounded flex items-center gap-1">
                                                        <svg xmlns="http://www.w3.org/2000/svg" className="h-3 w-3" viewBox="0 0 20 20" fill="currentColor">
                                                            <path fillRule="evenodd" d="M10 5a1 1 0 011 1v3h3a1 1 0 110 2h-3v3a1 1 0 11-2 0v-3H6a1 1 0 110-2h3V6a1 1 0 011-1z" clipRule="evenodd" />
                                                        </svg>
                                                        Last
                                                    </button>
                                                    {dance.stepSheetLink && (
                                                        <a href={dance.stepSheetLink} target="_blank" rel="noopener noreferrer" className="text-purple-400 hover:text-purple-500" title="View Step Sheet">
                                                            <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                                                <path d="M10 12a2 2 0 100-4 2 2 0 000 4z" />
                                                                <path fillRule="evenodd" d="M.458 10C1.732 5.943 5.522 3 10 3s8.268 2.943 9.542 7c-1.274 4.057-5.064 7-9.542 7S1.732 14.057.458 10zM14 10a4 4 0 11-8 0 4 4 0 018 0z" clipRule="evenodd" />
                                                            </svg>
                                                        </a>
                                                    )}
                                                    <button onClick={() => { setEditingDance(dance); setIsModalOpen(true); }} className="text-yellow-400 hover:text-yellow-500" title="Edit">
                                                        <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                                            <path d="M13.586 3.586a2 2 0 112.828 2.828l-.793.793-2.828-2.828.793-.793zM11.379 5.793L3 14.172V17h2.828l8.38-8.379-2.83-2.828z" />
                                                        </svg>
                                                    </button>
                                                    <button onClick={() => setConfirmDelete(dance)} className="text-red-600 hover:text-red-700" title="Delete">
                                                        <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                                            <path fillRule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v6a1 1 0 102 0V8a1 1 0 00-1-1z" clipRule="evenodd" />
                                                            </svg>
                                                    </button>
                                                </div>
                                            </td>
                                        </tr>
                                    ))}
                                </tbody>
                            </table>
                        </div>
                    ) : (
                        <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4 p-4">
                            {displayedDances.map((dance) => (
                                <div key={dance.id} className="relative bg-gray-700 rounded-lg shadow-md p-4 flex flex-col justify-between">
                                    {bulkEditMode && (
                                        <div className="absolute top-2 left-2">
                                            <input type="checkbox" checked={selectedDances.has(dance.id)} onChange={() => handleSelectDance(dance.id)} className="form-checkbox text-blue-500 bg-gray-800 rounded-md focus:ring-cyan-400" />
                                        </div>
                                    )}
                                    <button 
                                        onClick={() => bulkEditMode ? handleBulkToggleBeginnerFriendly(dance) : handleToggleBeginnerFriendly(dance)} 
                                        className={`absolute top-2 right-2 w-8 h-8 flex items-center justify-center font-bold text-sm rounded-full transition-colors z-10 
                                            ${(editedDances[dance.id]?.isBeginnerFriendly ?? dance.isBeginnerFriendly) ? 'neon-pink-bg text-white neon-glow' : 'bg-gray-800 text-gray-400 border-2 border-gray-600'}`} 
                                        title="Toggle Beginner Friendly">
                                        B
                                    </button>
                                    <div>
                                        <h3 className="text-lg font-bold text-cyan-300 mb-1">
                                            {bulkEditMode ? (
                                                <input type="text" value={editedDances[dance.id]?.danceName ?? dance.danceName} onChange={(e) => handleBulkEditChange(dance.id, 'danceName', e.target.value)} className="w-full bg-gray-600 border border-gray-500 rounded p-1" />
                                            ) : (
                                                dance.danceName
                                            )}
                                        </h3>
                                        <p className="text-sm text-gray-300">
                                            {bulkEditMode ? (
                                                <input type="text" value={editedDances[dance.id]?.songTitle ?? dance.songTitle} onChange={(e) => handleBulkEditChange(dance.id, 'songTitle', e.target.value)} className="w-full bg-gray-600 border border-gray-500 rounded p-1" />
                                            ) : (
                                                dance.songTitle
                                            )}
                                        </p>
                                        <p className="text-xs text-gray-400">
                                            {bulkEditMode ? (
                                                <input type="text" value={editedDances[dance.id]?.songArtist ?? dance.songArtist} onChange={(e) => handleBulkEditChange(dance.id, 'songArtist', e.target.value)} className="w-full bg-gray-600 border border-gray-500 rounded p-1" />
                                            ) : (
                                                dance.songArtist
                                            )}
                                        </p>
                                    </div>
                                    <div className="mt-4 flex flex-wrap gap-2 items-center">
                                        {bulkEditMode ? (
                                             <select value={editedDances[dance.id]?.difficulty ?? dance.difficulty} onChange={(e) => handleBulkEditChange(dance.id, 'difficulty', e.target.value)} className="text-xs font-semibold px-2 py-1 rounded-full bg-gray-600 text-white border-gray-500">
                                                <option value="Beginner">Beginner</option>
                                                <option value="Improver">Improver</option>
                                                <option value="Intermediate">Intermediate</option>
                                                <option value="Advanced">Advanced</option>
                                            </select>
                                        ) : (
                                            <span className="text-xs font-semibold px-2 py-1 rounded-full text-white" style={{
                                                backgroundColor:
                                                    dance.difficulty === 'Beginner' ? '#34d399' :
                                                    dance.difficulty === 'Improver' ? '#60a5fa' :
                                                    dance.difficulty === 'Intermediate' ? '#fde047' :
                                                    dance.difficulty === 'Advanced' ? '#f87171' : '#a1a1aa'
                                            }}>{dance.difficulty}</span>
                                        )}
                                        <div className="flex-grow"></div>
                                        <div className="flex space-x-2">
                                            <button onClick={() => handleAddToQueue(dance, 'next')} className="bg-green-600 hover:bg-green-700 text-white text-xs font-bold py-1 px-2 rounded flex items-center gap-1">
                                                <svg xmlns="http://www.w3.org/2000/svg" className="h-3 w-3" viewBox="0 0 20 20" fill="currentColor">
                                                    <path fillRule="evenodd" d="M10 5a1 1 0 011 1v3h3a1 1 0 110 2h-3v3a1 1 0 11-2 0v-3H6a1 1 0 110-2h3V6a1 1 0 011-1z" clipRule="evenodd" />
                                                </svg>
                                                Next
                                            </button>
                                            <button onClick={() => handleAddToQueue(dance, 'last')} className="bg-blue-600 hover:bg-blue-700 text-white text-xs font-bold py-1 px-2 rounded flex items-center gap-1">
                                                <svg xmlns="http://www.w3.org/2000/svg" className="h-3 w-3" viewBox="0 0 20 20" fill="currentColor">
                                                    <path fillRule="evenodd" d="M10 5a1 1 0 011 1v3h3a1 1 0 110 2h-3v3a1 1 0 11-2 0v-3H6a1 1 0 110-2h3V6a1 1 0 011-1z" clipRule="evenodd" />
                                                </svg>
                                                Last
                                            </button>
                                        </div>
                                    </div>
                                    <div className="flex justify-end mt-2 space-x-2">
                                        {dance.stepSheetLink && (
                                            <a href={dance.stepSheetLink} target="_blank" rel="noopener noreferrer" className="text-purple-400 hover:text-purple-500" title="View Step Sheet">
                                                <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                                    <path d="M10 12a2 2 0 100-4 2 2 0 000 4z" />
                                                    <path fillRule="evenodd" d="M.458 10C1.732 5.943 5.522 3 10 3s8.268 2.943 9.542 7c-1.274 4.057-5.064 7-9.542 7S1.732 14.057.458 10zM14 10a4 4 0 11-8 0 4 4 0 018 0z" clipRule="evenodd" />
                                                </svg>
                                            </a>
                                        )}
                                        <button onClick={() => { setEditingDance(dance); setIsModalOpen(true); }} className="text-yellow-400 hover:text-yellow-500" title="Edit">
                                            <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                                <path d="M13.586 3.586a2 2 0 112.828 2.828l-.793.793-2.828-2.828.793-.793zM11.379 5.793L3 14.172V17h2.828l8.38-8.379-2.83-2.828z" />
                                            </svg>
                                        </button>
                                        <button onClick={() => setConfirmDelete(dance)} className="text-red-600 hover:text-red-700" title="Delete">
                                            <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                                <path fillRule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v6a1 1 0 102 0V8a1 1 0 00-1-1z" clipRule="evenodd" />
                                            </svg>
                                        </button>
                                    </div>
                                </div>
                            ))}
                        </div>
                    )
                )}
            </div>
        </div>
    );
};

// Main App component to wrap the FirebaseProvider
const App = () => (
    <FirebaseProvider>
        <LineDanceManagement />
    </FirebaseProvider>
);

export default App;
